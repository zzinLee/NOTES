# Server Driven UI에 대해 알아보자

최근 회사에서 프로젝트를 진행하면서 프로필 입력 관련 UI를 Server Driven UI로 교체하는 작업을 진행했습니다. <br>
추후 확장될 시장을 위하여 유사하지만 반복되는 UI를 매번 개발하지 않고 서버를 통해 빠르게 대응하기 위한 방안이었습니다. <br>
급하게 진행하느라 제대로 된 구조를 짜지 못한 것 같다는 생각에 조금 더 찾아보고 구조를 리팩터링 하는 것이 좋겠다고 생각하여 아래의 아티클을 보고 정리하게 되었습니다.<br>

### 참고한 자료

[카카오스타일 기술 블로그 [Server Driven UI 설계를 통한 UI유연화]](https://devblog.kakaostyle.com/ko/2021-12-16-1-server-driven-ui)<br>

<br>

## Server Driven UI의 배경 | 앱은 배포 후 수정이 불가능하다

앱은 빌드 및 배포 후 사용자가 직접 업데이트 하지 않는 이상 수정이 불가능합니다. <br>
이와 같은 맥락으로 앱을 배포할 때에는 최적의 UX/UI를 제공하는 것이 중요한데, 이를 예측하기가 어려워 A/B Test를 진행하곤 합니다. <br> 각 그룹에게 서로 다른 UI를 제공하여 가장 적합한 UI를 결정하는 테스트를 진행하여 하나로 통합하는 것이죠. <br>
이렇듯, 유연한 UI를 제공하려면 UI가 클라이언트(네이티브 앱)의 빌드와 배포로부터 자유로워야 합니다. <br>
이를 위하여 웹뷰와 같은 방식을 선택할 수도 있지만, 웹뷰 사용만으로는 불충분한 경우 Server-Driven-UI에 대해 고려해보게 됩니다.<br>
위 글에서는 네이티브 모바일 앱의 UI를 유연하게 다루기 위한 Server Driven UI 설계에 대해 소개합니다.<br>

<br>

## 서버에서 UI를 다루기

서버는 언제든 변경하고 배포할 수 있습니다. <br>
서버에서 제공하는 API를 이용해 동적으로 클라이언트 UI를 구성한다면, 앱을 매번 업데이트 하지 않고도 원하는 UI를 동적으로 변경할 수 있을 겁니다. <br>

아래의 사진은 서버의 응답에 따라 렌더링한 Home 화면입니다. <br>
홈화면 렌더를 위하여 클라이언트는 `GET/screens/home` 요청을 보내고 UI 요소 렌더링에 필요한 데이터들을 JSON 포맷 응답으로 받습니다. <br>

<br>

<img src="https://devblog.kakaostyle.com/img/content/2021-12-16-1/2021-12-16-1-01.png" width="550" />

<br>

> [!NOTE] 응답의 특징
>
> 1) data 에는 배열 타입으로 전달되며, 해당 배열 순서대로 UI 렌더링
> 2) type 에 따라 컴포넌트를 렌더링
> 3) 각 컴포넌트를 렌더하는데에 필요한 텍스트 데이터를 text 로 전달
> 4) 다음 렌더링에 필요한 엔드포인트를 route 로 전달

위와 같은 구조로 관리한다면 서버의 배포만으로 클라이언트가 유연하게 UI를 제공할 수 있습니다. 이와 같이 UI에 대한 정보를 서버에서 관리하고 제공하는 것이 Server Driven UI 설계의 기본 개념입니다. <br>

<br>

## 재사용 가능한 UI 컴포넌트 제공하기
서버의 응답에 따라 UI를 교체해야 하므로 Server Driven UI 설계에서 사용하는 컴포넌트는 **재사용성**이 중요합니다. 하지만 수시로 화면에 컴포넌트가 추가 및 제거된다면, 서버와 클라이언트 사이의 **타입 정의 불일치**에 의한 문제가 발생할 수 있습니다. <br>
이때 사용할 수 있는 해결책이 GraphQL 입니다. 서버와 클라이언트가 스키마를 공유하고 API 타입 안정성을 보장할 수 있습니다.
<br>

## 쿼리설계
서버는 UI컴포넌트 리스트를 반환하는 screen query를 통해 화면 UI 정보를 제공합니다.
아래는 GraphQL의 스키마 정의입니다.

```ts
type Query {
  screen(screenType: ScreenType!): Screen!
}

enum ScreenType {
  HOME,
  SIGN_IN
}

type Screen {
  components: [Component!]!
}
```
